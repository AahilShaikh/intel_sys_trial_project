#include <chrono>
#include <memory>
#include <random>
#include <string>
#include <vector>

#include "geometry_msgs/msg/point.hpp"
#include "nav_msgs/msg/occupancy_grid.hpp"
#include "nav_msgs/msg/path.hpp"
#include "rclcpp/rclcpp.hpp"

using namespace std::chrono_literals;

class PathPublisher : public rclcpp::Node {
  public:
    PathPublisher() : Node("path_publisher") {
        publisher_ = this->create_publisher<nav_msgs::msg::Path>("path", rclcpp::QoS(1).transient_local());

        mapSubscription_ = this->create_subscription<nav_msgs::msg::OccupancyGrid>(
            "map", rclcpp::QoS(1).transient_local(), std::bind(&PathPublisher::updateMap, this, std::placeholders::_1));

        startingSubscription_ = this->create_subscription<geometry_msgs::msg::Point>(
            "start", rclcpp::QoS(1).transient_local(),
            std::bind(&PathPublisher::updateStartPos, this, std::placeholders::_1));
            
        goalSubscription_ = this->create_subscription<geometry_msgs::msg::Point>(
            "goal", rclcpp::QoS(1).transient_local(),
            std::bind(&PathPublisher::updateGoal, this, std::placeholders::_1));
    }

  private:
    struct PathNode {
        int x, y;
        float g_cost = std::numeric_limits<float>::infinity();
        float h_cost = 0;
        PathNode *parent = nullptr;

        PathNode(int x_val, int y_val) : x(x_val), y(y_val) {
        }

        float f_cost() const {
            return g_cost + h_cost;
        }
    };

    struct NodeComparator {
        bool operator()(const PathNode *a, const PathNode *b) const {
            return a->f_cost() > b->f_cost();
        }
    };

    nav_msgs::msg::OccupancyGrid::SharedPtr map_ = nullptr;
    geometry_msgs::msg::Point::SharedPtr start_ = nullptr;
    geometry_msgs::msg::Point::SharedPtr goal_ = nullptr;

    rclcpp::Subscription<nav_msgs::msg::OccupancyGrid>::SharedPtr mapSubscription_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr startingSubscription_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr goalSubscription_;
    rclcpp::Publisher<nav_msgs::msg::Path>::SharedPtr publisher_;

    void updateMap(const nav_msgs::msg::OccupancyGrid::SharedPtr msg) {
        RCLCPP_INFO(this->get_logger(), "Map received.");
        map_ = msg;
        createPath();
    }

    void updateStartPos(const geometry_msgs::msg::Point::SharedPtr msg) {
        RCLCPP_INFO(this->get_logger(), "Starting position received.");
        start_ = msg;
        createPath();
    }

    void updateGoal(const geometry_msgs::msg::Point::SharedPtr msg) {
        RCLCPP_INFO(this->get_logger(), "Goal Position received.");
        goal_ = msg;
        createPath();
    }

    float heuristic_(int x1, int y1, int x2, int y2) {
        return std::abs(x1 - x2) + std::abs(y1 - y2);
    }

    /**
     * Reconstrcuts the shortest path generated by the A* algorithm
     */
    std::vector<PathNode *> reconstructPath(PathNode *goal_node) {
        std::vector<PathNode *> path;
        PathNode *current = goal_node;
        while (current != nullptr) {
            path.push_back(current);
            current = current->parent;
        }
        std::reverse(path.begin(), path.end());
        return path;
    }

    void createPath() {
        if (map_ == nullptr || start_ == nullptr || goal_ == nullptr) {
            return;
        }

        const int width = map_->info.width;
        const int height = map_->info.height;

        // A* Star algorithm: https://en.wikipedia.org/wiki/A*_search_algorithm

        std::unordered_map<int, PathNode> all_nodes;
        std::priority_queue<PathNode *, std::vector<PathNode *>, NodeComparator> open_set;
        std::unordered_set<int> closed_set;

        PathNode &start_node =
            all_nodes.emplace(start_->y * width + start_->x, PathNode(start_->x, start_->y)).first->second;
        start_node.h_cost = heuristic_(start_node.x, start_node.y, goal_->x, goal_->y);
        start_node.g_cost = 0;
        open_set.push(&start_node);

        PathNode *goal_node_ptr = nullptr;
        while (!open_set.empty()) {
            PathNode *curr = open_set.top();
            open_set.pop();

            // Found target
            if (curr->x == goal_->x && curr->y == goal_->y) {
                goal_node_ptr = curr;
                break;
            }

            int currIdx = curr->y * width + curr->x;
            closed_set.insert(currIdx);

            const int dx[] = {0, 0, 1, -1};
            const int dy[] = {1, -1, 0, 0};

            for (int i = 0; i < 4; ++i) {
                int neighbor_x = curr->x + dx[i];
                int neighbor_y = curr->y + dy[i];
                int neighbor_idx = neighbor_y * width + neighbor_x;

                // Skip neighbor if out of bounds, already processed, or if it contains an obstacle
                if (neighbor_x < 0 || neighbor_x >= width || neighbor_y < 0 || neighbor_y >= height) {
                    continue;
                }
                if (map_->data[neighbor_idx] == 100 || closed_set.count(neighbor_idx) > 0) {
                    continue;
                }

                float tentative_g_cost = curr->g_cost + 1.0f;

                if (!all_nodes.count(neighbor_idx)) {
                    all_nodes.emplace(neighbor_idx, PathNode(neighbor_x, neighbor_y));
                }
                PathNode &neighbor_node = all_nodes.at(neighbor_idx);

                if (tentative_g_cost < neighbor_node.g_cost) {
                    neighbor_node.parent = curr;
                    neighbor_node.g_cost = tentative_g_cost;
                    neighbor_node.h_cost = heuristic_(neighbor_x, neighbor_y, goal_->x, goal_->y);
                    open_set.push(&neighbor_node);
                }
            }
        }

        // Create path message and publish it
        if (goal_node_ptr) {
            std::vector<PathNode *> path_nodes = reconstructPath(goal_node_ptr);
            auto path_msg = nav_msgs::msg::Path();
            path_msg.header.frame_id = "map";
            path_msg.header.stamp = this->get_clock()->now();

            for (const auto &node : path_nodes) {
                geometry_msgs::msg::PoseStamped pose;
                pose.header = path_msg.header;
                pose.pose.position.x = node->x;
                pose.pose.position.y = node->y;
                path_msg.poses.push_back(pose);
            }
            RCLCPP_INFO(this->get_logger(), "Publishing path");
            publisher_->publish(path_msg);
        } else {
            RCLCPP_INFO(this->get_logger(), "Path not found");
        }
    }
};

int main(int argc, char *argv[]) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<PathPublisher>());
    rclcpp::shutdown();
    return 0;
}